
```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE
)
```
## Introduction ‚ú®
L'√©quipe de projet `The World (Taylor's Version)` est compos√©e de quatres personnes : Marielle CHARON, Kevin HERNANDEZ, Anouchka NEVEU et Amadou ISSAKA AMADOU. Le but de ce projet est de r√©pondre √† plusieurs questions sur le th√®me de la musique et plus pr√©cisement sur les platformes Spotify et Youtube grace √† la visualisation de donn√©es. Le projet sera d√©velopp√© sous R.

## Donn√©es üí°
Le dataset utilis√© (`Datasetfinal.csv`) est un merge de deux datasets : [Spotify and Youtube](https://www.kaggle.com/datasets/salvatorerastelli/spotify-and-youtube) et [Spotify songs](https://www.kaggle.com/datasets/sujaykapadnis/spotify-songs). Le merge final p√®se 6.55 MB et est sous format CSV. Il contient 3668 √©l√©ments. La cl√© qui a servi au merge est l'ID de la musique sur Spotify.

Les deux jeux de donn√©es contiennent des donn√©es datant de **2023** collect√©es depuis les API officielles de YouTube et Spotify. On a, notamment, les 10 musiques les plus populaires d'une vari√©t√© d'artistes.

> Il poss√®de √† l'heure actuelle 50 features, avant cleaning de celles pertinentes.
<br>
On regroupe les features sous ces cat√©gories :
<br><br>

| Cat√©gorie | Features associ√©es |
| --- | --- |
| Informations g√©n√©rales | artist, track_name, album, album_type, duration_ms, channel, description, track_album_release_date, ... |
| Scores musicaux | danceability, energy, key, loudness, acousticness, instrumentalness, liveness, valence, tempo |
| Popularit√© | views, likes, comments, stream, track_popularity |
| Variables suppl√©mentaires | uri (Spotify ID), url_spotify, url_youtube, licensed, ... |

> Les variables suppl√©mentaires n'expliquent pas la donn√©e pour l'analyse, mais sont utilis√©es pour structurer le dataset.
<br>
Les features se r√©partissent selon plusieurs types : nominales (nom de l'artiste/musique/album, ...), discr√®tes (tonalit√©) ou continues (scores musicaux).

#### Features audio üéµ

Les features audio sont des donn√©es extraites des musiques elles-m√™mes par l'API Spotify. Elles sont calcul√©es par des algorithmes de traitement du signal audio. Ces algorithmes ne sont pas publics, mais voici ce que Spotify dit de ces features :


| Param√®tre         | Intervalle | Description |
|-------------------|------------|-------------|
| danceability      | 0-1        | La danceability d√©crit √† quel point une piste est adapt√©e √† la danse en fonction de divers √©l√©ments musicaux (tempo, beats, r√©gularit√©...). Plus la valeur est √©lev√©e, plus la piste est dansante |
| energy            | 0-1        | L'√©nergie est une mesure qui repr√©sente une mesure perceptuelle de l'intensit√© et de l'activit√©. Les pistes √©nergiques ont une intensit√© rapide et forte (par exemple, le death metal a une haute √©nergie). Les mesures perceptives utilis√©es comprennent la gamme dynamique, l'intensit√© sonore per√ßue, le timbre et l'entropie g√©n√©rale |
| instrumentalness  | 0-1        | Pr√©dit si une piste ne contient aucun contenu vocal. Les sons "Ooh" et "aah" sont trait√©s comme des instruments. Les pistes instrumentales sont souvent des pistes de musique classique ou de musique √©lectronique |
| liveness          | 0-1        | D√©tecte la pr√©sence d'un public dans l'enregistrement. Les valeurs sup√©rieures √† 0,8 fournissent une forte probabilit√© que la piste soit un enregistrement en direct |
| loudness          | ~ -60-0    | L'intensit√© sonore globale d'une piste en d√©cibels (dB). Les valeurs d'intensit√© sonore sont calcul√©es en moyenne sur l'ensemble de la piste |
| speechiness       | 0-1        | D√©tecte la pr√©sence de mots parl√©s dans une piste. Plus la valeur est proche de 1, plus la piste est probablement enti√®rement constitu√©e de mots parl√©s. Les valeurs sup√©rieures √† 0,66 d√©crivent des pistes qui sont probablement enti√®rement parl√©es. Les valeurs comprises entre 0,33 et 0,66 d√©crivent des pistes qui peuvent contenir √† la fois de la musique et des paroles, soit en sections, soit en couches, y compris des cas tels que la musique rap. Les valeurs inf√©rieures √† 0,33 repr√©sentent tr√®s probablement de la musique et d'autres pistes ne ressemblant pas √† des paroles |
| mode              | 0-1        | Le mode indique la modalit√© (majeure ou mineure) de la piste. Les pistes en mode majeur sonnent g√©n√©ralement plus joyeuses, tandis que les pistes en mode mineur sonnent plus tristes |
| tempo             | ~ 50-200   | Le tempo global estim√© d'une piste en battements par minute (BPM). Dans la terminologie musicale, le tempo est la vitesse ou le rythme d'une pi√®ce donn√©e et d√©rive directement de la dur√©e moyenne du battement |
| valence           | 0-1        | Une mesure d√©crivant la "positivit√© musicale" transmise par une piste. Les morceaux ayant une valence √©lev√©e sonnent plus postifis, tandis que les morceaux ayant une valence faible sonnent plus n√©gatifs (musiques joyeuses vs musiques tristes) |
| key               | 0-11       | La cl√© de la piste. Intervalle de 0 √† 11, repr√©sentant les notes de musique de Do √† Si |
| popularity        | 0-100      | La popularit√© de la piste. La popularit√© de la piste est calcul√©e en fonction du nombre de streams Spotify sur une p√©riode de temps |



```{r, echo=FALSE, include=FALSE}
# DATASET CLEANING AND PRACTICAL CODE

# Install packages if necessary
# install.packages("cowplot")

# library import
library(ggplot2)
library(readr)
library(dplyr)
library(forcats)
library(devtools)
library(palettetown)
library(cowplot)
library(stats)
library(plotly)
library(ggcorrplot)
library(GGally)
library(treemapify)
library(tidyr)
library(fmsb)
library(gridExtra)


# import dataset
data <- read_csv("data/datasetfinal.csv")
data <- data.frame(data)

taylor_data <- read_csv("data/taylor_swift_albums.csv")
taylor_data <- data.frame(taylor_data)

# clean dataset
data <- data %>%
  select(-c(playlist_name, playlist_id, Url_spotify, Url_youtube, Title, Duration_ms, Danceability, Energy, Key, Loudness, Speechiness, Acousticness, Instrumentalness, Liveness, Valence, Tempo, track_name, track_artist)) %>%   # remove useless features
  na.omit() %>%   # remove incomplete rows
  distinct(Uri, .keep_all = TRUE)   # remove duplicated rows

# Turn release date to years
data$track_album_release_date <- as.Date(data$track_album_release_date)
data$track_album_release_year <- as.numeric(format(data$track_album_release_date, "%Y"))

# add relevant features to dataset
data$total_streams <- data$Stream + data$Views
data <- arrange(data, desc(total_streams))

# Generate a gradient of green colors
green_colors <- colorRampPalette(c("#3de076", "#000000"))(length(unique(data$key)))

#D√©finition des couleurs pour les genres de musique (graphiques coh√©rents)


palette_couleurs_unique <- c("rap" = "#4A79E7",
                             "pop" = "#F28E2B",
                             "r&b" = "#E15759",
                             "edm" = "#76B7E2",
                             "latin" = "#59A13F",
                             "rock" = "#9999EF")
```


#### Qualit√© des donn√©es üéØ
Avant de se plonger dans l'anaylyse, on tient √† noter les biais du dataset.

```{r, echo=FALSE}

# Graph of distribution of the number of musics per genre, ordered by the number of musics
ggplot(data, aes(fill = playlist_genre, x = reorder(playlist_genre, -table(playlist_genre)[playlist_genre]))) +
  geom_bar() +
  scale_fill_manual("Genre", values = palette_couleurs_unique) +
  ggtitle("Distribution du nombre de musiques par genre") +
  xlab("Genre") +
  ylab("Nombre de musiques")

```


On remarque tout de suite le biais du dataset, avec une surrepr√©sentation des musiques **Rock** et une sous-repr√©sentation des musiques **EDM**. Cela sera √† prendre en compte dans les analyses.

De m√™me, les donn√©es ont √©t√© prises de mani√®re *arbitraire*, sans crit√®res pr√©cis, en r√©cup√©rant un jeu de musiques pour une liste d'artistes choisis. Il est donc possible que les musiques s√©lectionn√©es ne soient pas repr√©sentatives de la r√©alit√©. Il est important de garder cela en t√™te lors de l'analyse.


#### Analyse Exploratoire du Dataset avec Tableau

Avant de r√©pondre √† nos diff√©rentes interrogations, nous avons effectu√© une analyse exploratoire de notre jeu de donn√©es √† l‚Äôaide de tableau. De ces visualisations pouvant √™tre filtr√© par ann√©e, on arrive √† mieux cerner la composition de notre Dataset.

![**Tableau de bord**](image/capture dashboard.png)


Apr√®s suppression des doublons, nous avons 1948 chansons et on constate √† travers le tableau de r√©partition par genre que le rock est le genre le plus repr√©sent√© avec 230 artistes et 598 chansons tir√©es de 455 albums contrairement √† l‚ÄôEDM avec 65 artistes et 89 chansons tir√©es de 83 albums.

Comme l‚Äôindique son nom, la visualisation suivante illustre la r√©partition par genre des musiques publi√©es ou non sur les pages officielles des artistes. On s‚Äôaper√ßoit qu‚Äôil existe dans notre dataset, un nombre non-n√©gligeable de musiques qui sont post√©es sur YouTube par des pages non-officielles. Si l'on prend l'exemple du rap, ce nombre repr√©sente quasiment plus 1/4 des sons. Ensuite, le graphique suivant traduit cette fois, la r√©partition par genre des sons qui sont produits sous la licence d‚Äôune maison de production ou d‚Äôun label de musique.

La derni√®re visualisation, quant √† elle, met en √©vidence, une comparaison entre les diff√©rents genres musicaux √† travers quelques caract√©ristiques (avec des valeurs entre 0 et 1) qui sont : Acousticness, Danceability, Energy, Liveness et Speechiness. 

On s‚Äôimagine le rap avec plus de mots parl√©s, mais aussi l‚Äôedm, la musique latine, la pop, le r&b un peu plus dansant que le rap et le rock qui eux seront plus √©nergique avec l‚Äôedm. √Ä notre grande surprise, le graphique r√©v√®le √©tonnamment un rock plus acoustique et le rap est plus dansant malgr√© une diff√©rence non-flagrante, mais conforte notre th√©orie sur les mots parl√©s. Comme imagin√©, l‚Äôedm et le rock se classent, comme les musiques les plus √©nergiques. On peut imaginer que la quantit√© de donn√©es a jou√© un r√¥le dans les r√©sultats √©tonnant que nous avons pu observer.


## R√©ponses aux questions ü§î 

> Quels sont les artistes les plus populaires sur YouTube et Spotify ? Et est-ce que on a les m√™me r√©sulats selon la plateforme ?


```{r, echo=FALSE}

# Create the data frame with the top 20 artists with the most cumulative total streams on all their musics
top_artists <- data %>%
  group_by(Artist) %>%
  summarise(total_streams = sum(Stream + Views)) %>%
  arrange(desc(total_streams)) %>%
  head(20)

# Create a long format data frame for stacked bar chart
long_data <- data %>%
  filter(Artist %in% top_artists$Artist) %>%
  group_by(Artist) %>%
  summarise(Spotify = sum(Stream), YouTube = sum(Views)) %>%
  pivot_longer(cols = c(Spotify, YouTube), names_to = "Platform", values_to = "Streams")

# Plotting
ggplot(long_data, aes(y = Streams, x = fct_reorder(Artist, Streams, sum), fill = Platform)) + 
  geom_bar(position = "stack", stat = "identity") +
  ggtitle("Top 20 des artistes avec le plus de streams totaux (Spotify et YouTube)") +
  ylab("Nombre Total de streams (Spotify et YouTube)") +
  xlab("Artistes") +
  coord_flip() +
  scale_y_continuous(labels = scales::comma) +
  scale_fill_manual("Plateforme", values = c("Spotify" = "#1DB954", "YouTube" = "#FF0000"))

```

On voit rapidement que dans notre dataset, Ed Sheeran et Coldplay se d√©tachent en terme de streams totaux. Cela s'explique notamment par la pr√©sence de 3 musiques d'Ed Sheeran √† + de 3 milliards de vues (Perfect, Thinking Out Loud, Shape of You). De m√™me pour Coldplay, avec 4 musiques √† + d'1 milliard de vues (Paradise, Hymn for the Weekend, Something Just Like This, The Scientist).

Il est int√©ressant de voir la r√©partition des streams entre Spotify et YouTube. On voit par exemple que pour Luis Fonsi, la majorit√© des streams se font sur YouTube ; ceci s'explique par son hit *Despacito*. Sur Youtube, les gens ont tendance √† √©couter les musiques populaires quelques fois, alors que sur Spotify, l'audience √©coute en boucle les chansons de ses artistes pr√©f√©r√©s. D'o√π le fait que des musiques comme *Despacito* soient largement + √©cout√©es sur YouTube que Spotify. A l'inverse, les musiques d'AC/DC, XXXTENTACION ou Queen sont largement plus √©cout√©es sur Spotify que YouTube, indiquant une plus forte portion d'auditeurs fid√®les sur Spotify.


> Quelles sont les chansons les plus populaires sur YouTube et Spotify ?

> Y a-t'il une corr√©lation entre les genres de musique et leur cl√© musicale ?

Dans le graphique ci-dessous, on voit les 15 chansons les plus √©cout√©es (streams cumul√©s sur YouTube et Spotify). On voit rapidement que *Ed Sheeran* domine le classement puisqu'il cumule 3 des 15 chansons les plus √©cout√©es.
‚ö†Ô∏è **CELA NE REPRESENTE PAS LES ARTISTES AVEC LE PLUS DE STREAMS TOTAUX CUMULES**

On d√©cide d'analyser ces musiques en fonction de leur cl√© musicale. Dans le dataset, chaque cl√© est associ√©e √† un entier selon [cet encodage](https://en.wikipedia.org/wiki/Pitch_class#:~:text=%5Bedit%5D-,Pitch%20class,-Pitch%0Aclass).
Globalement, plus une cl√© est √©lev√©e, plus une chanson a tendance √† √™tre a√Øgue. A l'inverse, une chanson √† cl√© basse sera plus grave.

Sur l'ensemble du dataset, la cl√© moyenne est :

```{r, echo=FALSE}
mean(data$key)
```
soit un *Fa*.


```{r, echo=FALSE}

# Convert 'key' to a factor
data_factor <- data %>%
  mutate(key = as.factor(key))


# Create the bar plot with shades of green for the fill
ggplot(head(data_factor, 15), aes(fill = key, y = total_streams, x = fct_reorder(Artist, total_streams, sum))) + 
    geom_bar(position = "stack", stat = "identity") +
    geom_text(aes(label = Track), position = position_stack(vjust = 0.5), color = "white", size = 2) +
    ggtitle("Top 15 des musiques avec le Nombre total de streams (S and YT) par artistes et cl√© ") +
    ylab("Nombre total de streams (S and YT)") +
    xlab("Artistes") +
    
    # turning the graph sideways and switching from scientific notation to regular notation for numbers
    coord_flip() +
    scale_y_continuous(labels = scales::comma) +
    scale_fill_manual("Cl√©", values = green_colors)

```

Si on s'int√©resse uniquement aux 15 premi√®res chansons, la cl√© moyenne devient alors :

```{r, echo=FALSE}
mean(head(data,15)$key)
```
plus proche d'un *Mi* (soit une cl√© inf√©rieure).

```{r, echo=FALSE}
ggplot(data, aes(x = fct_reorder(playlist_genre, -key, mean), y = key, fill = playlist_genre)) +
  geom_boxplot() +
  scale_fill_manual(values = palette_couleurs_unique) +  
  labs(fill = "Genre", x = "Genre", y = "Cl√©") +
  ggtitle("Whisker Plot des cl√©s par genre pour toutes les musiques") +
  coord_flip()
```

En regardant les genres de toutes les musiques du dataset, on voit que le genre avec la cl√© m√©diane la plus √©lev√©e est le rap. Les genres les moins vari√©s en terme de de cl√©s musicales sont le rock et l'EDM (Electronic Dance Music).

‚ö†Ô∏è Il est √† noter que la classification du genre des musiques dans le dataset peut parfois √™tre hasardeuse.





> Quelle est la dur√©e moyenne des chansons par artiste ? Est-ce qu'il y a des artistes qui ont des chansons plus longues ou plus courtes que la moyenne ?

L'id√©e √† travers ces diff√©rentes interrogations est de pouvoir situer les artistes en fonction de la dur√©e moyenne de leurs chansons. Pour cela, nous allons dans un premier temps voir la ***distribution*** de la dur√©e moyenne de chansons √† l'aide d'un ***histogramme***, et ensuite faire la ***comparaison*** entre ces artistes. Avant cela, il est important de noter que :


```{r duration_stats, echo=FALSE,}
Convert_en_m <- function(ms){
  minute <- ms/60000
  intPart <- floor(minute)
  decimalPat <- minute - intPart
  decimalPat <- floor(decimalPat * 60)
  return(paste(c(intPart,"mn",decimalPat,"s"),collapse = ''))
}

mean_in_s <- round(mean(data$duration_ms)/1000,2)
max_in_s <- round(max(data$duration_ms)/1000,2)
min_in_s <- round(min(data$duration_ms)/1000,2)
  
paste(c("la dur√©e moyenne d'une musique est de: ", mean_in_s, "s soit ",Convert_en_m(mean(data$duration_ms))),collapse = '')
paste(c("La musique la plus longue dure: ", max_in_s, "s soit ",Convert_en_m(max(data$duration_ms))),collapse = '')
paste(c("La musique la plus courte dure: ", min_in_s , "s soit ",Convert_en_m(min(data$duration_ms))),collapse = '')

```

```{r Histogramme, echo=FALSE, fig.align='center'}

dfArtisDuration_mean <- data %>% group_by(Artist) %>% summarise (duration_mean = mean(duration_ms)) %>% mutate(duration_mean_in_sec = duration_mean/1000)

dfArtisDuration_sup_mean <- dfArtisDuration_mean %>% filter(duration_mean_in_sec > mean_in_s) %>% arrange(desc(duration_mean))

dfArtisDuration_infEg_mean <- dfArtisDuration_mean %>% filter(duration_mean_in_sec <= mean_in_s) %>% arrange(duration_mean)


ggplot(dfArtisDuration_mean, mapping = aes(x = duration_mean_in_sec)) +
  geom_histogram(mapping = aes(
    fill = ifelse(duration_mean_in_sec <= mean(duration_mean_in_sec), "En dessous de la moyenne", "Au dessus de la moyenne")
  ), binwidth =5) +
  scale_fill_manual(
    name = 'Classification par dur√©e moyenne des musiques',
    values = c("En dessous de la moyenne" = "#191414", "Au dessus de la moyenne" = "#1DB954")
  ) +
  ggtitle("Distribution de la dur√©e des musiques") +
  xlab("Dur√©e en secondes") +
  ylab("Nombre d'artistes")


```

On constate √† travers cet histogramme que toutes les chansons de notre dataset durent plus de 100s soit plus d'une 1mn40s et qu'il y en a qui vont jusqu'√† plus de 400s soit plus de 6mn. Cependant malgr√© la faible domination des songs dans la moyenne g√©n√©rale de dur√©e, un certain nombre d'artistes proposent une discographie de musiques plus longues.

Si l'on pousse la curiosit√© encore plus loin, on peut faire le top 10 des artistes qui produisent en moyenne plus de longues ou au contraire plus de courtes musiques. Pour cela, nous, utiliserons un ***Bar_Chart*** pour faire la ***comparaison*** entre ces artistes.

```{r Artist mean duration , echo=FALSE, fig.align='center', fig.height=6, fig.width=15}

# Get the maximum duration_mean_in_sec from both data frames and add a buffer
max_duration <- max(max(dfArtisDuration_sup_mean$duration_mean_in_sec), max(dfArtisDuration_infEg_mean$duration_mean_in_sec))
buffer <- 0.1 * max_duration  # 10% buffer
max_duration <- max_duration + buffer

g1 <- ggplot(head(dfArtisDuration_sup_mean, 10), aes(y = duration_mean_in_sec, x = Artist, fill = Artist)) +
  geom_bar(position = "stack", stat = "identity") +
  geom_hline(yintercept = mean_in_s) +
  annotate("text", x = -1, y = mean_in_s + 10, label = 'Mean', hjust = 'left') +
  geom_text(aes(label = round(duration_mean_in_sec, 2), angle = 70), position = position_stack(vjust = 1.1)) +
  theme(axis.text.x = element_blank(), axis.title.x = element_blank()) +
  ggtitle("Top 10 des artistes avec les plus longues musiques (moyenne)") +
  ylab("Dur√©e en secondes") +
  ylim(0, max_duration)
  

g2 <- ggplot(head(dfArtisDuration_infEg_mean,10), mapping = aes(y = duration_mean_in_sec,x=Artist,fill = Artist)) +
   geom_bar(position = "stack", stat = "identity") +
   geom_hline(yintercept = mean_in_s) +
   annotate("text", x=-1, y = mean_in_s + 10, label='Mean', hjust = 'left' )+
   geom_text(aes(label = round(duration_mean_in_sec,2), angle = 70), position = position_stack(vjust = 1.1)) +
   theme(axis.text.x = element_blank(), axis.title.x = element_blank()) +
   ggtitle("Top 10 des artistes avec les plus courte musiques (moyenne)") +
   ylab("Dur√©e en secondes") +
   ylim(0, max_duration)


# Plot the graphs side by side with the same y-axis scale
plot_grid(g1, g2, ncol = 2)

```



Sur ces 2 graphiques, on peut voir que dans les deux tops 10, la moyenne des artistes se d√©tache largement de la dur√©e moyenne du dataset et que "*Bob Marley & The Wailers*" fait plus de longues chansons contrairement √† "*Pouya*" qui a la moyenne la plus basse.

‚ö†Ô∏è Il est important de relativiser, car il ne faut pas perdre de vue que nous sommes en pr√©sence d'un dataset qui ne contient pas toute la discographie de ces artistes.

```{r, echo=FALSE}

#Select the 5 artists with the most songs in the dataset
most_song_artists <- data %>%
  group_by(Artist) %>%
  summarise(total_songs = n()) %>%
  arrange(desc(total_songs)) %>%
  head(5)

most_song_artists_data <- data %>%
  filter(Artist %in% most_song_artists$Artist)

# Create the plot
ggplot(most_song_artists_data, aes(x = track_album_release_year, y = duration_ms, color = Artist)) +
  geom_point() +
  geom_smooth(method = "loess", se = FALSE) +
  ggtitle("Evolution de la dur√©e des chansons au fil du temps, pour quelques artistes") +
  xlab("Ann√©es") +
  ylab("Dur√©e (s)") +
  theme_minimal() +
  scale_y_continuous(labels = scales::comma)

```

On observe ici les 5 artists poss√©dant le plus de musiques dans le dataset. On voit que la dur√©e des chansons de ces artistes a tendance √† augmenter au fil des ann√©es. Cela peut s'expliquer par le fait que les artistes ont tendance profiter d'une plus grande libert√© artistique une fois que leur communaut√© est marqu√©e, ou √† une √©volution de leur style musical.

Nous allons ici prendre l'exemple de Taylor Swift, gr√¢ce √† sa discographie extensive s'√©tendant sur 11 albums, 4 r√©-enregistrements et 18 ans de carri√®re.


```{r, echo=FALSE, fig.align='center', fig.height=10, fig.width=10}

# Extract the year from the release_date column
taylor_data <- taylor_data %>%
  mutate(release_year = lubridate::year(release_date))

# Create a vector of colors for each unique release year
unique_years <- unique(taylor_data$release_year)
color_palette <- rainbow(length(unique_years))

# Map colors
year_colors <- setNames(color_palette, unique_years)
album_colors <- c("#7ede7e", "#f5d64e", "#cb94e3", "#bf1d34", "#74d6fc", "#4d4849", "#f774a8", "#CDC9C1", "#c77f50", "#3156ad", "#8e39b3", "#f7f6e9")


# Create the plot
ggplot(taylor_data, aes(x = reorder(album, release_date), y = duration_ms, fill = as.factor(release_year))) +
  geom_boxplot() +
  ggtitle("Evolution de la dur√©e des chansons au fil du temps (Taylor Swift)") +
  xlab("Albums") +
  ylab("Dur√©e (s))") +
  theme_minimal() +
  scale_y_continuous(labels = scales::comma, limits = c(0, 620000)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  scale_fill_manual("Ann√©e de sortie", values = album_colors)


```

Dans le cas de Taylor Swift, on que la dur√©e des chansons fluctue d'album en album, mais qu'aucune r√©elle tendance ne se d√©gage. Toutefois, on voit que l'album *Speak Now* (Taylor's Version) est tr√®s long, avec une dur√©e moyenne de chansons de pr√®s de 5 minutes. Cela s'explique en partie par le fait que la chanteuse a √©crit cet album en pensant que ce serait son dernier, ayant d√©j√† d√©pass√© le pic de sa carri√®re avec son pr√©c√©dent album *Fearless*. Ce ne fut pas le cas, mais l'album reste un des plus longs de sa discographie du fait de la libert√© cr√©ative qu'elle y a pris.

On remarque aussi plusieurs outliers, avec notamment une chanson de 6 minutes, et une chanson de 10 minutes, qui en restent certaines des chansons les plus √©cout√©es et appr√©ci√©es de sa discographie **(chiffres de stream juin 2024)**.

```{r, echo=FALSE}
longest_songs <- taylor_data %>%
  arrange(desc(duration_ms)) %>%
  head(2)

longest_songs$streams_spotify <- c(840899011, 105316578)
longest_songs$streams_youtube <- c(251178119, 9699483)
longest_songs <- longest_songs %>%
  select(name, album, duration_ms, streams_spotify, streams_youtube)

longest_songs
```


Avec ces constats, on est en droit de se demander si la dur√©e des chansons a un r√©el impact sur leur popularit√©.

> Les chansons plus longues ont-elles une popularit√© diff√©rente ?

En tant que m√©lomane, on a tendance √† croire que les chansons les plus longues sont moins populaires en raison de la tendance actuelle des artistes pour les musiques de courte dur√©e. Afin d'affirmer ou d'infirmer cette th√©orie, nous allons √† l'aide d'un ***Scatter Plot***, √©tudier la ***relation*** entre la dur√©e et la popularit√© des diff√©rents songs du dataset.

```{r duration & popularity, echo=FALSE, fig.align='center'}
data %>% select(track_popularity, duration_ms) %>% 
  ggplot( mapping = aes(y = track_popularity, x=duration_ms/1000 )) + 
  geom_point() + 
  geom_smooth()+
  ggtitle("Scattter Plot : Dur√©e & Popularit√©") +
  xlab("Dur√©e (s)") +
  ylab("Popularit√© des tracks (%)")

```

√Ä travers ce nuage de points, on observe :

-   une forte concentration de songs ayant une dur√©e comprise entre 200 et 300 secondes et avec une popularit√© oscillant entre 60 et 80 %.
-   les songs les plus, mais aussi les moins populaires se situent dans la m√™me plage de dur√©e,
-   les musiques les plus courtes et les plus longues partagent la m√™me plage de popularit√©.
-   la dispersion du nuage de points par rapport √† la droite de r√©gression.

Tout ceci nous pousse √† douter de l'existence d'une r√©elle relation entre la popularit√© et la dur√©e d'une musique. Dans le doute, on se r√©f√®re au coefficient de corr√©lation qui est de :

```{r Coefficient, echo=FALSE,}
coeff<-cor(x = data$duration_ms, y =data$track_popularity)
coeff
```

Le r√©sultat n√©gatif traduit une corr√©lation n√©gative, c'est-√†-dire que les deux variables √©voluent en direction oppos√©e, ce qui conforte nos soup√ßons sur l'impopularit√© des longues chansons. Cette relation demeure tr√®s faible et nous pensons que la taille de notre jeu de donn√©es ne nous permet pas de s'assurer ais√©ment de cette relation.



> Quel genre de musique est le plus populaire sur Spotify/Youtube ?

Dans le graphique ci-dessous, nous pouvons voir le classement des genres de musiques par rapport au nombre moyen de stream (sur spotify et youtube) que fait une musique de ce genre, ce qui donne donc un classement de popularit√©. On choisi cette m√©thode de *"nombre moyen de stream que fait une musique"* pour cat√©goriser la popularit√© des genres car nous ne pouvons pas simplement afficher un nombre total de Stream pour chaque genre sachant qu'il n'y a pas un nombre √©gal de musique par genre. Il faut diviser le nombre total de stream par genre par le nombre de musique de ce genre, ce qui donne un nombre moyen de stream pour chaque genre.


```{r, echo=FALSE}

# Calculer la moyenne du nombre de streams (par musique) pour chaque genre de musique
total_streams_genre <- data %>%
  group_by(playlist_genre) %>%
  summarise(total_streams = sum(total_streams),
            total_tracks = n()) %>%
  mutate(mean_streams_per_track = ceiling(total_streams / total_tracks))  # Arrondir √† l'entier sup√©rieur

# Cr√©er le graphique en utilisant la moyenne du nombre de streams pour chaque genre
ggplot(total_streams_genre, aes(x = reorder(playlist_genre, mean_streams_per_track, .desc=TRUE), y = mean_streams_per_track, fill = playlist_genre)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = mean_streams_per_track), position = position_stack(vjust = 0.5), color = "black", size = 3) +  # Ajouter le nombre de streams moyen par genre
  scale_fill_manual(values = palette_couleurs_unique) +  
  labs(x = "Genre de musique", y = "Nombre de stream moyen", fill = "Genre") +
  ggtitle("Nombre de streams moyen (d'une musique) pour chaque genre de musique") +
  coord_flip() +
  scale_y_continuous(labels = scales::comma)

```

La premiere chose que l'on remarque c'est que l'**EDM** (Electronic Dance Music) est en t√™te de classement suivie par la **Pop** et les musiques **Latin(o)**. Pourtant si on reprend les 15 musiques les plus populaire et qu'on les classe par genre, on se rend compte que le **Latin(o)** domine le classement, suivit par la **Pop** puis enfin l'**EDM**. Comme le montre le graphique ci-dessous.


```{r, echo=FALSE}
# Cr√©er le graphique √† barres empil√©es par genre
ggplot(head(data, 15), aes(fill = Track, y = total_streams, x = fct_reorder(playlist_genre, total_streams, .desc=TRUE))) +
  geom_bar(position = "stack", stat = "identity") +
  ggtitle("Top 15 des musiques (par nombre total de streams) par genre") +
  labs(y = "Total streams (S and YT)", x = "Genre", fill = "Top 15 Musiques") +
  scale_y_continuous(labels = scales::comma)
```

Pour r√©sumer ces deux graphiques, dans ce dataset, le genre de musique le plus populaire est l'EMD (sur un nombre moyen d'√©coute) mais parmi le top 15 des musiques, le genre de musique le plus populaire est le Latin(o).
Alors, comment expliquer cette diff√©rence de r√©sulat ? 

Grace au diagramme Whisker Plot [(d√©finition)](https://cdn2.boryl.fr/2020/11/3d5689a5-box-plot-boi%CC%82tes-a%CC%80-moustaches--300x223.png) ci-dessous, on voit que le classement par la m√©diane nous donne encore une information diff√©rente en mettant la Pop en premi√®re place. C'est normal et m√™me plus juste car la **moyenne est sensible aux "outliers"**, tandis que la m√©diane est plus robuste √† leur pr√©sence. Si un petit nombre de valeurs extr√™mes sont significativement plus √©lev√©es que les autres valeurs de l'ensemble de donn√©es, elles peuvent tirer la moyenne vers le haut, tandis que la m√©diane reste relativement stable. De plus l'impact sur la moyenne peut varier en fonction de la quantit√© de donn√©es et de la r√©partition des valeurs extr√™mes.

```{r, echo=FALSE}
# Cr√©er le graphique de type "Whisker Plot" par genre avec la moyenne
ggplot(data, aes(x = fct_reorder(playlist_genre, -total_streams, .desc = TRUE), y = total_streams, fill = playlist_genre)) +
  geom_boxplot() +
  stat_summary(fun = "mean", geom = "point", shape = 18, size = 3, color = "black", position = position_dodge(width = 0.75)) +  # Ajouter la moyenne
  scale_fill_manual(values = palette_couleurs_unique) +  
  labs(fill = "Genre", x = "Genre", y = "Streams totaux par musique") +
  ggtitle("Whisker Plot : r√©partition du Nombre total de Streams (par musique) par genre") +
  coord_flip() +
  scale_y_continuous(labels = scales::comma)

```
En analysant le m√™me graphique sous forme de Violin Plot, on observe plus ais√©ment que les genres Rap, Rock et R&B ont beaucoup plus de musiques avec un faible nombre de streams, compar√© aux genres EDM, Pop et Latin(o) qui ont une r√©partition plus √©quilibr√©e. 

```{r, echo=FALSE}
# Cr√©er le graphique de type "Whisker Plot" par genre avec la moyenne
ggplot(data, aes(x = fct_reorder(playlist_genre, -total_streams, .desc = TRUE), y = total_streams, fill = playlist_genre)) +
  geom_violin() +
  stat_summary(fun = "mean", geom = "point", shape = 18, size = 3, color = "black", position = position_dodge(width = 0.75)) +  # Ajouter la moyenne
  scale_fill_manual(values = palette_couleurs_unique) +  
  labs(fill = "Genre", x = "Genre", y = "Streams totaux par musique") +
  ggtitle("Violin Plot :  r√©partition du Nombre total de Streams (par musique) par genre") +
  scale_y_continuous(labels = scales::comma)

```


Comme on peut le voir dans le tableau ci dessous, le genre EDM contient beaucoup moins de musique par rapport √† la Pop ou au Latin(o), donc le petit nombre de musiques extr√™mes (en nombre de stream) √† une grande influence sur la moyenne de stream ce qui a tendance √† fausser notre classement initial.

```{r, echo=FALSE}

tableau_genre_musiques <- data %>%
  count(playlist_genre) %>%
  rename(Genre = playlist_genre, Nombre_de_musiques = n)

tableau_genre_musiques
```

Que faut-il conclure pour cette question ? Le classement par la m√©diane est plus pertinent, ce qui place donc la **Pop comme le genre le plus populaire**.
Pour le genre Latin(o), les musiques font g√©n√©ralement moins de streams que l'EDM et la Pop sauf quelques cas particuliers qui apparaissent dans notre top 15 des musiques les plus populaire.

‚ö†Ô∏è Il est √† noter cette √©tude est bas√©e sur les musiques pr√©sente dans le dataset et pas sur toute les musiques existantes.


> Est ce que l'energie d'une musique joue un r√¥le important dans sa popularit√© ?

C'est une question l√©gitime, existe t'il une corr√©lation entre l'energie d'une musique ainsi que sa popularit√© (total du nombre de streams sur les 2 plateformes). 
Nous analysons cette question avec 2 graphiques utilisant les m√™mes donn√©es. Le 1er graphique est un scatter plot avec une moyenne mobile du nombre de streams. Le 2nd est le m√™me graphique sans le nuage de points pour mieux analyser la moyenne mobile qui semble constante sur le 1er.
 
```{r}
ggplot(data, aes(x = energy, y = total_streams)) + geom_point() +
  geom_smooth() +
  labs(x = "Energie", y = "Streams totaux", title = "Scatter Plot : Energie et Streams") +
  theme_minimal()
```

On peut remarquer que la densit√© d'√©nergie avec le plus de musiques se situe entre 0.4 et 1.

```{r}
ggplot(data, aes(x = energy, y = total_streams)) +
  geom_smooth() +
  labs(x = "Energie", y = "Total Streams", title = "Correlation entre √©nergie et streams totaux") +
  theme_minimal()
```

L'√©volution de la moyenne mobile est nettement plus analysable sans le nuage de points. On peut remarquer que la moyenne du nombre de streams augmente entre 0 et 0.75 d'energy pour ensuite diminuer entre 0.75 et 1. Il y a une croissance de pr√®s de 25% entre 0.25 et 0.75 d'energy et une chute de 33% du nombre de streams entre 0.75 et 1. On peut donc conclure qu'il y a une certaine corr√©lation entre l'energy et le nombre de streams.

> Quelle est la r√©partition des caract√©ristiques musicales (tempo, danceability, etc.) dans les chansons les plus populaires ?

```{r}
top_musiques <- data[order(data$total_streams, decreasing = TRUE), ][1:5, ]

# Normalisation des variables
normalize <- function(x) {
  return((x - min(x)) / (max(x) - min(x)))
}

top_musiques_norm <- as.data.frame(lapply(top_musiques[, c("energy", "danceability", "speechiness", "tempo", "duration_ms")], normalize))

# Ajouter des lignes pour les valeurs maximales et minimales
top_musiques_norm <- rbind(rep(1, 5), rep(0, 5), top_musiques_norm)

# Couleurs personnalis√©es
colors <- c("#59A13F", "#76B7E2", "#F28E2B", "#e7298a", "#9999EF")

# Titres des axes
axis_labels <- c("Energy", "Danceability", "Speechiness", "Tempo", "Duration")

# D√©placer le graphique sur la gauche
par(mar = c(5, 0, 4, 0))

# Cr√©er le radar chart
radarchart(top_musiques_norm, 
           axistype = 1, 
           pcol = colors,
           plty = 1, 
           plwd = 2,
           title = "Radar Chart des Meilleures Musiques",
           axislabcol = "white",
           cglcol = "grey",
           cglty = 1,
           cglwd = 0.8,
           vlcex = 0.8,
           vlabels = axis_labels)

# Ajouter une l√©gende avec les noms des musiques
par(xpd=TRUE)  # Permettre le dessin en dehors des marges du graphique
legend("topright", legend = top_musiques$Track, col = colors, lty = 1, lwd = 2, cex = 0.8, bty = "n")
```


> Quelles ann√©es ont connu le plus de streams ?

> Quelle est l'√©volution de la r√©partition des genres de musique au fil des ann√©es ?

Dans le graphique ci-dessous, on voit les streams totaux des musiques sorties sur la m√™me ann√©e, selon leur genre. On s'int√©resse seulement √† la p√©riode 2000 2019 (le dataset ne comprenant qu'un faible √©chantillon de musiques en 2020).



```{r echo=FALSE}

data_2000_2019 <- data %>%
  filter(track_album_release_year >= 2000 & track_album_release_year <= 2019) %>%
  group_by(track_album_release_year, playlist_genre) %>%
  summarise(total_streams = sum(total_streams))

#Fill les genre manquant par ann√©es
years <- seq(2000, 2019)
genres <- unique(data_2000_2019$playlist_genre)
all_combinations <- expand.grid(track_album_release_year = years, playlist_genre = genres)

data_2000_2019 <- all_combinations %>%
  left_join(data_2000_2019, by = c("track_album_release_year", "playlist_genre"))

data_2000_2019$total_streams[is.na(data_2000_2019$total_streams)] <- 0



g1 <- ggplot(data_2000_2019, aes(x = track_album_release_year, y = total_streams, fill = playlist_genre)) +
  geom_area(alpha=0.8 , size=0.5, colour="black") +
  ggtitle("Streams totaux des musiques sorties sur la m√™me ann√©e, selon leur genre") +
  ylab("Nombre Total de streams (S and YT)") +
  xlab("Ann√©es") +
  scale_fill_manual(values = palette_couleurs_unique) +
  scale_y_continuous(labels = scales::comma)

data_2000_2019_perc <- data_2000_2019 %>%
  group_by(track_album_release_year, playlist_genre) %>%
  summarise(total_streams = sum(total_streams)) %>%
  mutate(percentage = total_streams / sum(total_streams))

g2 <- ggplot(data_2000_2019_perc, aes(x = track_album_release_year, y = percentage, fill = playlist_genre)) +
  geom_area(alpha=0.8 , size=0.5, colour="black") +
  ggtitle("Pourcentage des streams totaux des musiques sorties sur la m√™me ann√©e, selon leur genre") +
  ylab("Pourcentage des streams totaux") +
  xlab("Ann√©es") +
  scale_fill_manual(values = palette_couleurs_unique) +
  scale_y_continuous(labels = scales::percent)

plot_grid(g1, g2, ncol = 1)

```

Globalement, on peut voir que les ann√©es 2010 ont connu une explosion des plateformes de streaming de musique commme Spotify ou Youtube, ce qui se traduit par un pic de streams sur la graphique.

Par rapport aux genres, on voit que les musiques Rock ont connu un pic de streams dans les ann√©es 2000, avant de chuter drastiquement. Au contraire, dans la fin des ann√©es 2010, le genre Rap prend de plus en plus d'importance dans le monde de la musique. Le genre Latino a connu une tr√®s grosse √©volution en 2017 et 2018, avec la sortie, entre autres, de **Despacito** de Luis Fonsi et Daddy Yankee ou **MIA** de Bad Bunny et Drake.

> Est-ce que les musiques qui ont le plus de "Views" sur Youtube sont √©galement celle qui ont le plus de "Stream" sur Spotify ? Dans la m√™me id√©e, est-ce que les musiques qui ont le plus de "Views" sont √©galement celle qui ont le plus de "Likes" et de "Comments" ?

Pour cette question, le graphique dynamique est disponible dans l'application **Shiny** d√©di√©e, dans l'onglet **Top 40 Musiques**. Vous pouvez s√©lectionner la variable afin d'afficher le graphique. Nous ferons cette analyse pour un top 15 des musiques, mais dans l'application vous pouvez √©galement aller jusqu'au top 40 gr√¢ce au curseur.


![ScreenShot Shiny Views et Streams](image/shiny_view_stream.png)



Pour commencer, ce que nous pouvons remarquer de ces deux graphiques c'est que le top 15 de Youtube et le top 15 de Spotify n'est pas le m√™me. Il est m√™me tr√®s  √©loign√©, car la seule musique en commun est *Shape of You*. *Despacito*, qui a le plus de "Views" sur Youtube n'est m√™me pas dans le top 40 Stream car il fait environ la moiti√© de "Streams" Spotify par rapport a *Shape of You*.

Deux choses peuvent expliquer ce gros √©cart, soit les donn√©es n'ont pas √©t√© r√©cup√©r√©es au m√™me moment par les API quand le dataset a √©t√© cr√©e (en sachant que ces donn√©es viennent du m√™me dataset) et donc certaines musiques ont fait plus de vue entre temps ou alors elles √©taient pas en "top popularit√©" √† ce moment l√† et donc n'ont pas √©t√© s√©l√©ctionn√©e par l'API. Soit, Youtube est une platforme gratuite et tout le monde ne paye pas un abonnement pour une platforme de musique, donc si une musique commence √† devenir populaire il y a de grande chance qu'on l'√©coute sur cette platforme √† un moment donn√©. De plus tout le monde n'√©coute pas sa musique sur Spotify car il existe d'autres applications payantes (exemple : Deezer), donc il peut √©galement exister des types de profils par rapport aux platforme. 

Dans tout les cas, les **algorithmes** pour les propositions de musiques ne sont **pas identiques** entre Spotify et Youtube, donc les musiques propos√©e ne sont pas identique et cela peut faire **changer** la popularit√© (et donc le nombre de views/streams) d'une musique d'une platforme √† une autre.


![ScreenShot Shiny Likes et Comments](image/shiny_like_comment.png)


On remarque en revanche sur ces deux graphiques plusieurs musiques du top 15 en "Views" √©galement pr√©sentes dans le top 15 "Likes" et "Comments", notamement *Despacito*, *Shape of you* ou *See you again*. Les classements ne sont pas excatement identique, mais on retrouve plusieurs musiques en commun donc il existe surement un **lien** entre le nombre de "views" et le nombre de "likes" / "comments". Nous allons le v√©rifier avec une matrice de corr√©lation.

```{r}
# S√©lectionner uniquement les colonnes n√©cessaires
data_selected <- data %>%
  select(Views, Likes, Comments)

# Cr√©er le graphique de croisements deux √† deux et la matrice de corr√©lation
ggpairs(data_selected, 
        upper = list(continuous = wrap("cor", size = 6, face = "bold", color = "#f00000")),
        lower = list(continuous = wrap("smooth", alpha = 0.7, color = "#2ca02c")),
        diag = list(continuous = wrap("barDiag", fill = "#1f77b4"))) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 12, face = "bold"),
    panel.grid.major = element_line(color = "gray80"),
    panel.grid.minor = element_blank(),
    axis.text = element_text(size = 7),
    axis.title = element_text(size = 10),
    strip.background = element_rect(fill = "gray90"),
    strip.text = element_text(size = 10, face = "bold")
  ) +
  labs(title = "Croisement deux √† deux et matrice de corr√©lation pour Views, Likes et Comments")
```

Dans ce graphique de croisements deux √† deux avec la matrice de corr√©lation, on confirme gr√¢ce aux co√©ffients, que nous avons une **correlation forte** entre les trois variables : Views, Likes et Comments. 

> Est-ce qu'il existe des liens de corr√©lation entre certaines variables : danceability, energy, loudness, speechiness, acousticness, instrumentalness, liveness, valence, tempo, total_streams ?
Et, existe-t-il des liens entre certaines variables et le nombre de streams total ?

De m√™me pour cette question, le graphique dynamique est disponible dans l'application **Shiny** d√©di√©e, dans l'onglet **Matrice de corr√©lation**. Cette matrice est clicable, c'est √† dire que que si vous cliquez sur la case rouge entre energy et loudness, vous aurez le graphique correspondant √† droite et le coeficient de corr√©lation en dessous.

![ScreenShot correlation energy loudness](image/correlation1.png)
La matrice de correlation nous indique qu'il y a une **correlation forte** (0,67) entre l'energie et le volume sonore (loudness), et entre l'energie et l'accoustique (0,53). Mais  √©galement une **corr√©lation moyenne** entre l'accoustique et le volume sonore (0,38). Les autres corr√©lation sont plus faibles, et contrairement √† nos suppositions, il n'y a pas de correlation notable entre le nombre total de streams (Youtube + Spotify) et certaines variables.
