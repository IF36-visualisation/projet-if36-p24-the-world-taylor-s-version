
```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE
)
```
## Introduction ‚ú®
L'√©quipe de projet `The World (Taylor's Version)` est compos√©e de quatres personnes : Marielle CHARON, Kevin HERNANDEZ, Anouchka NEVEU et Amadou ISSAKA AMADOU. Le but de ce projet est de r√©pondre √† plusieurs questions sur le th√®me de la musique et plus pr√©cisement sur les platformes Spotify et Youtube grace √† la visualisation de donn√©es. Le projet sera d√©velopp√© sous R.

## Donn√©es üí°
Le dataset utilis√© (`Datasetfinal.csv`) est un merge de deux datasets : [Spotify and Youtube](https://www.kaggle.com/datasets/salvatorerastelli/spotify-and-youtube) et [Spotify songs](https://www.kaggle.com/datasets/sujaykapadnis/spotify-songs). Le merge final p√®se 6.55 MB et est sous format CSV. Il contient 3668 √©l√©ments. La cl√© qui a servi au merge est l'ID de la musique sur Spotify.

Les deux jeux de donn√©es contiennent des donn√©es datant de **2023** collect√©es depuis les API officielles de YouTube et Spotify. On a, notamment, les 10 musiques les plus populaires d'une vari√©t√© d'artistes.

> Il poss√®de √† l'heure actuelle 50 features, avant cleaning de celles pertinentes.
<br>
On regroupe les features sous ces cat√©gories :
<br><br>

| Cat√©gorie | Features associ√©es |
| --- | --- |
| Informations g√©n√©rales | artist, track_name, album, album_type, duration_ms, channel, description, track_album_release_date, ... |
| Scores musicaux | danceability, energy, key, loudness, acousticness, instrumentalness, liveness, valence, tempo |
| Popularit√© | views, likes, comments, stream, track_popularity |
| Variables suppl√©mentaires | uri (Spotify ID), url_spotify, url_youtube, licensed, ... |

> Les variables suppl√©mentaires n'expliquent pas la donn√©e pour l'analyse, mais sont utilis√©es pour structurer le dataset.
<br>
Les features se r√©partissent selon plusieurs types : nominales (nom de l'artiste/musique/album, ...), discr√®tes (tonalit√©) ou continues (scores musicaux).


```{r, echo=FALSE, include=FALSE}
# DATASET CLEANING AND PRACTICAL CODE

# Install packages if necessary
# install.packages("cowplot")

# library import
library(ggplot2)
library(readr)
library(dplyr)
library(forcats)
library(devtools)
library(palettetown)
library(cowplot)
library(stats)
library(plotly)
library(ggcorrplot)
library(GGally)
library(treemapify)
library(tidyr)


# import dataset
data <- read_csv("data/datasetfinal.csv")
data <- data.frame(data)

# clean dataset
data <- data %>%
  select(-c(playlist_name, playlist_id, Url_spotify, Url_youtube, Title, Duration_ms, Danceability, Energy, Key, Loudness, Speechiness, Acousticness, Instrumentalness, Liveness, Valence, Tempo, track_name, track_artist)) %>%   # remove useless features
  na.omit() %>%   # remove incomplete rows
  distinct(Uri, .keep_all = TRUE)   # remove duplicated rows
  

# add relevant features to dataset
data$total_streams <- data$Stream + data$Views
data <- arrange(data, desc(total_streams))
#D√©finition des couleurs pour les genres de musique (graphiques coh√©rents)

palette_couleurs_unique <- c("rap" = "#4A79E7",
                             "pop" = "#F28E2B",
                             "r&b" = "#E15759",
                             "edm" = "#76B7E2",
                             "latin" = "#59A13F",
                             "rock" = "#9999EF")
```


#### Qualit√© des donn√©es üéØ

Avant de se plonger dans l'anaylyse, on tient √† noter les biais du dataset.

```{r, echo=FALSE}
# graph of distribution of the number of musics per genre, ordered by the number of musics
ggplot(data, aes(fill = playlist_genre, x = reorder(playlist_genre, -table(playlist_genre)[playlist_genre]))) +
  geom_bar() +
  scale_fill_manual(values = palette_couleurs_unique) +
  ggtitle("Distribution of the number of musics per genre") +
  xlab("Genre") +
  ylab("Number of musics")

```


On remarque tout de suite le biais du dataset, avec une surrepr√©sentation des musiques **Rock** et une sous-repr√©sentation des musiques **EDM**. Cela sera √† prendre en compte dans les analyses.

De m√™me, les donn√©es ont √©t√© prises de mani√®re *arbitraire*, sans crit√®res pr√©cis, en r√©cup√©rant un jeu de musiques pour une liste d'artistes choisis. Il est donc possible que les musiques s√©lectionn√©es ne soient pas repr√©sentatives de la r√©alit√©. Il est important de garder cela en t√™te lors de l'analyse.



## R√©ponses aux questions ü§î 

> Quelles sont les chansons les plus populaires sur YouTube et Spotify ?

> Y a-t'il une corr√©lation entre les genres de musique et leur cl√© musicale ?

Dans le graphique ci-dessous, on voit les 15 chansons les plus √©cout√©es (streams cumul√©s sur YouTube et Spotify). On voit rapidement que *Ed Sheeran* domine le classement puisqu'il cumule 3 des 15 chansons les plus √©cout√©es.
‚ö†Ô∏è **CELA NE REPRESENTE PAS LES ARTISTES AVEC LE PLUS DE STREAMS TOTAUX CUMULES**

On d√©cide d'analyser ces musiques en fonction de leur cl√© musicale. Dans le dataset, chaque cl√© est associ√©e √† un entier selon [cet encodage](https://en.wikipedia.org/wiki/Pitch_class#:~:text=%5Bedit%5D-,Pitch%20class,-Pitch%0Aclass).
Globalement, plus une cl√© est √©lev√©e, plus une chanson a tendance √† √™tre a√Øgue. A l'inverse, une chanson √† cl√© basse sera plus grave.

Sur l'ensemble du dataset, la cl√© moyenne est :

```{r, echo=FALSE}
mean(data$key)
```
soit un *Fa*.


```{r, echo=FALSE}
# PLOT 1 : Top X songs from total streams (S and YT) by artist and key

# Convert 'key' to a factor
data_factor <- data %>%
  mutate(key = as.factor(key))

# Generate a gradient of green colors
green_colors <- colorRampPalette(c("#3de076", "#000000"))(length(unique(data$key)))

# Create the bar plot with shades of green for the fill
ggplot(head(data_factor, 15), aes(fill = key, y = total_streams, x = fct_reorder(Artist, total_streams, sum))) + 
    geom_bar(position = "stack", stat = "identity") +
    geom_text(aes(label = Track), position = position_stack(vjust = 0.5), color = "white", size = 2) +
    ggtitle("Top 15 des musiques avec le Nombre total de streams (S and YT) par artistes et cl√© ") +
    ylab("Nombre Total de streams (S and YT)") +
    xlab("Artistes") +
    
    # turning the graph sideways and switching from scientific notation to regular notation for numbers
    coord_flip() +
    scale_y_continuous(labels = scales::comma) +
    scale_fill_manual(values = green_colors)
```

Si on s'int√©resse uniquement aux 15 premi√®res chansons, la cl√© moyenne devient alors :

```{r, echo=FALSE}
mean(head(data,15)$key)
```
plus proche d'un *Mi* (soit une cl√© inf√©rieure).

```{r, echo=FALSE}
ggplot(data, aes(x = fct_reorder(playlist_genre, -key, mean), y = key, fill = playlist_genre)) +
  geom_boxplot() +
  scale_fill_manual(values = palette_couleurs_unique) +  
  labs(fill = "Genre", x = "Genre", y = "Cl√©") +
  ggtitle("Whisker Plot des cl√©s par Genre pour toutes les musiques") +
  coord_flip()
```

En regardant les genres de toutes les musiques du dataset, on voit que le genre avec la cl√© m√©diane la plus √©lev√©e est le rap. Les genres les moins vari√©s en terme de de cl√©s musicales sont le rock et l'EDM (Electronic Dance Music).

‚ö†Ô∏è Il est √† noter que la classification du genre des musiques dans le dataset peut parfois √™tre hasardeuse.





> Quelle est la dur√©e moyenne des chansons par artiste ? Est-ce qu'il y a des artistes qui ont des chansons plus longues ou plus courtes que la moyenne ?

L'id√©e √† travers ces diff√©rentes interrogations est de pouvoir situer les artistes en fonction de la dur√©e moyenne de leurs chansons. Pour cela, nous allons dans un premier temps voir la ***distribution*** de la dur√©e moyenne de chansons √† l'aide d'un ***histogramme***, et ensuite faire la ***comparaison*** entre ces artistes. Avant cela, il est important de noter que :


```{r duration_stats, echo=FALSE,}
Convert_en_m <- function(ms){
  minute <- ms/60000
  intPart <- floor(minute)
  decimalPat <- minute - intPart
  decimalPat <- floor(decimalPat * 60)
  return(paste(c(intPart,"mn",decimalPat,"s"),collapse = ''))
}

mean_in_s <- round(mean(data$duration_ms)/1000,2)
max_in_s <- round(max(data$duration_ms)/1000,2)
min_in_s <- round(min(data$duration_ms)/1000,2)
  
paste(c("la dur√©e moyenne d'une musique est de: ", mean_in_s, "s soit ",Convert_en_m(mean(data$duration_ms))),collapse = '')
paste(c("La musique la plus longue dure: ", max_in_s, "s soit ",Convert_en_m(max(data$duration_ms))),collapse = '')
paste(c("La musique la plus courte dure: ", min_in_s , "s soit ",Convert_en_m(min(data$duration_ms))),collapse = '')

```

```{r Histogramme, echo=FALSE, fig.align='center'}

dfArtisDuration_mean <- data %>% group_by(Artist) %>% summarise (duration_mean = mean(duration_ms)) %>% mutate(duration_mean_in_sec = duration_mean/1000)

dfArtisDuration_sup_mean <- dfArtisDuration_mean %>% filter(duration_mean_in_sec > mean_in_s) %>% arrange(desc(duration_mean))

dfArtisDuration_infEg_mean <- dfArtisDuration_mean %>% filter(duration_mean_in_sec <= mean_in_s) %>% arrange(duration_mean)


ggplot(dfArtisDuration_mean, mapping = aes(x = duration_mean_in_sec)) +
  geom_histogram(mapping = aes(
    fill = ifelse(duration_mean_in_sec <= mean(duration_mean_in_sec), "En dessous de la moyenne", "Au dessus de la moyenne")
  ), binwidth =5) +
  scale_fill_manual(
    name = 'Classification by average song duration',
    values = c("Below Average" = "#191414", "Above Average" = "#1DB954")
  ) +
  ggtitle("Distribution de la dur√©e des musiques") +
  xlab("Dur√©e en secondes") +
  ylab("Nombre d'artistes")


```

On constate √† travers cet histogramme que toutes les chansons de notre dataset durent plus de 100s soit plus d'une 1mn40s et qu'il y en a qui vont jusqu'√† plus de 400s soit plus de 6mn. Cependant malgr√© la faible domination des songs dans la moyenne g√©n√©rale de dur√©e, un certain nombre d'artistes proposent une discographie de musiques plus longues.

Si l'on pousse la curiosit√© encore plus loin, on peut faire le top 10 des artistes qui produisent en moyenne plus de longues ou au contraire plus de courtes musiques. Pour cela, nous, utiliserons un ***Bar_Chart*** pour faire la ***comparaison*** entre ces artistes.

```{r Artist mean duration , echo=FALSE, fig.align='center', fig.height=6, fig.width=15}

# Get the maximum duration_mean_in_sec from both data frames and add a buffer
max_duration <- max(max(dfArtisDuration_sup_mean$duration_mean_in_sec), max(dfArtisDuration_infEg_mean$duration_mean_in_sec))
buffer <- 0.1 * max_duration  # 10% buffer
max_duration <- max_duration + buffer

g1 <- ggplot(head(dfArtisDuration_sup_mean, 10), aes(y = duration_mean_in_sec, x = Artist, fill = Artist)) +
  geom_bar(position = "stack", stat = "identity") +
  geom_hline(yintercept = mean_in_s) +
  annotate("text", x = -1, y = mean_in_s + 10, label = 'Mean', hjust = 'left') +
  geom_text(aes(label = round(duration_mean_in_sec, 2), angle = 70), position = position_stack(vjust = 1.1)) +
  theme(axis.text.x = element_blank(), axis.title.x = element_blank()) +
  ggtitle("Top 10 des artistes avec les plus longues musiques (moyenne)") +
  ylab("Dur√©e en secondes") +
  ylim(0, max_duration)

g2 <- ggplot(head(dfArtisDuration_infEg_mean,10), mapping = aes(y = duration_mean_in_sec,x=Artist,fill = Artist)) +
   geom_bar(position = "stack", stat = "identity") +
   geom_hline(yintercept = mean_in_s) +
   annotate("text", x=-1, y = mean_in_s + 10, label='Mean', hjust = 'left' )+
   geom_text(aes(label = round(duration_mean_in_sec,2), angle = 70), position = position_stack(vjust = 1.1)) +
   theme(axis.text.x = element_blank(), axis.title.x = element_blank()) +
   ggtitle("Top 10 des artistes avec les plus courte musiques (moyenne)") +
   ylab("Dur√©e en secondes") +
  ylim(0, max_duration)


# Plot the graphs side by side with the same y-axis scale
plot_grid(g1, g2, ncol = 2)

```



Sur ces 2 graphiques, on peut voir que dans les deux tops 10, la moyenne des artistes se d√©tache largement de la dur√©e moyenne du dataset et que "*Bob Marley & The Wailers*" fait plus de longues chansons contrairement √† "*Pouya*" qui a la moyenne la plus basse.

‚ö†Ô∏è Il est important de relativis√©, car il ne faut pas perdre de vue que nous sommes en pr√©sence d'un dataset qui ne contient pas toute la discographie de ces artistes.

Avec ces constats, on est en droit de se demander si la dur√©e des songs, n'a pas d'impact sur la popularit√© de la musique.

> Les chansons plus longues ont-elles une popularit√© diff√©rente ?

En tant que m√©lomane, on a tendance √† croire que les chansons les plus longues sont moins populaires en raison de la tendance actuelle des artistes pour les musiques de courte dur√©e. Afin d'affirmer ou d'infirmer cette th√©orie, nous allons √† l'aide d'un ***Scatter Plot***, √©tudier la ***relation*** entre la dur√©e et la popularit√© des diff√©rents songs du dataset.

```{r duration & popularity, echo=FALSE, fig.align='center'}
data %>% select(track_popularity, duration_ms) %>% 
  ggplot( mapping = aes(y = track_popularity, x=duration_ms/1000 )) + 
  geom_point() + 
  geom_smooth()+
  ggtitle("Scattter Plot : Dur√©e & Popularit√©") +
  xlab("Dur√©e en secondes") +
  ylab("Popularit√© des Tracks en pourcentage")

```

√Ä travers ce nuage de points, on observe :

-   une forte concentration de songs ayant une dur√©e comprise entre 200 et 300 secondes et avec une popularit√© oscillant entre 60 et 80 %.
-   les songs les plus, mais aussi les moins populaires se situent dans la m√™me plage de dur√©e,
-   les musiques les plus courtes et les plus longues partagent la m√™me plage de popularit√©.
-   la dispersion du nuage de points par rapport √† la droite de r√©gression.

Tout ceci nous pousse √† douter de l'existence d'une r√©elle relation entre la popularit√© et la dur√©e d'une musique. Dans le doute, on se r√©f√®re au coefficient de corr√©lation qui est de :

```{r Coefficient, echo=FALSE,}
coeff<-cor(x = data$duration_ms, y =data$track_popularity)
coeff
```

Le r√©sultat n√©gatif traduit une corr√©lation n√©gative, c'est-√†-dire que les deux variables √©voluent en direction oppos√©e, ce qui conforte nos soup√ßons sur l'impopularit√© des longues chansons. Cette relation demeure tr√®s faible et nous pensons que la taille de notre jeu de donn√©es ne nous permet pas de s'assurer ais√©ment de cette relation.



> Quel genre de musique est le plus populaire sur Spotify/Youtube ?

Dans le graphique ci-dessous, nous pouvons voir le classement des genres de musiques par rapport au nombre moyen de stream (sur spotify et youtube) que fait une musique de ce genre, ce qui donne donc un classement de popularit√©. On choisi cette m√©thode de *"nombre moyen de stream que fait une musique"* pour cat√©goriser la popularit√© des genres car nous ne pouvons pas simplement afficher un nombre total de Stream pour chaque genre sachant qu'il n'y a pas un nombre √©gal de musique par genre. Il faut diviser le nombre total de stream par genre par le nombre de musique de ce genre, ce qui donne un nombre moyen de stream pour chaque genre.


```{r, echo=FALSE}

# Calculer la moyenne du nombre de streams (par musique) pour chaque genre de musique
total_streams_genre <- data %>%
  group_by(playlist_genre) %>%
  summarise(total_streams = sum(total_streams),
            total_tracks = n()) %>%
  mutate(mean_streams_per_track = ceiling(total_streams / total_tracks))  # Arrondir √† l'entier sup√©rieur

# Cr√©er le graphique en utilisant la moyenne du nombre de streams pour chaque genre
ggplot(total_streams_genre, aes(x = reorder(playlist_genre, mean_streams_per_track, .desc=TRUE), y = mean_streams_per_track, fill = playlist_genre)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = mean_streams_per_track), position = position_stack(vjust = 0.5), color = "black", size = 3) +  # Ajouter le nombre de streams moyen par genre
  scale_fill_manual(values = palette_couleurs_unique) +  
  labs(x = "Genre de musique", y = "Nombre de stream moyen", fill = "Genre") +
  ggtitle("Nombre de streams moyen (d'une musique) pour chaque genre de musique") +
  coord_flip() +
  scale_y_continuous(labels = scales::comma)

```

La premiere chose que l'on remarque c'est que l'**EDM** (Electronic Dance Music) est en t√™te de classement suivie par la **Pop** et les musiques **Latin(o)**. Pourtant si on reprend les 15 musiques les plus populaire et qu'on les classe par genre, on se rend compte que le **Latin(o)** domine le classement, suivit par la **Pop** puis enfin l'**EDM**. Comme le montre le graphique ci-dessous.


```{r, echo=FALSE}
# Cr√©er le graphique √† barres empil√©es par genre
ggplot(head(data, 15), aes(fill = Track, y = total_streams, x = fct_reorder(playlist_genre, total_streams, .desc=TRUE))) +
  geom_bar(position = "stack", stat = "identity") +
  ggtitle("Top 15 des musiques (par nombre total de streams) par genre") +
  labs(y = "Total streams (S and YT)", x = "Genre", fill = "Top 15 Musiques") +
  scale_y_continuous(labels = scales::comma)

```

Pour r√©sumer ces deux graphiques, dans ce dataset, le genre de musique le plus populaire est l'EMD (sur un nombre moyen d'√©coute) mais parmi le top 15 des musiques, le genre de musique le plus populaire est le Latin(o).
Alors, comment expliquer cette diff√©rence de r√©sulat ? 

Grace au diagramme Whisker Plot [(d√©finition)](https://cdn2.boryl.fr/2020/11/3d5689a5-box-plot-boi%CC%82tes-a%CC%80-moustaches--300x223.png) ci-dessous, on voit que le classement par la m√©diane nous donne encore une information diff√©rente en mettant la Pop en premi√®re place. C'est normal et m√™me plus juste car la **moyenne est sensible aux "outliers"**, tandis que la m√©diane est plus robuste √† leur pr√©sence. Si un petit nombre de valeurs extr√™mes sont significativement plus √©lev√©es que les autres valeurs de l'ensemble de donn√©es, elles peuvent tirer la moyenne vers le haut, tandis que la m√©diane reste relativement stable. De plus l'impact sur la moyenne peut varier en fonction de la quantit√© de donn√©es et de la r√©partition des valeurs extr√™mes.

```{r, echo=FALSE}
# Cr√©er le graphique de type "Whisker Plot" par genre avec la moyenne
ggplot(data, aes(x = fct_reorder(playlist_genre, -total_streams, .desc = TRUE), y = total_streams, fill = playlist_genre)) +
  geom_boxplot() +
  stat_summary(fun = "mean", geom = "point", shape = 18, size = 3, color = "black", position = position_dodge(width = 0.75)) +  # Ajouter la moyenne
  scale_fill_manual(values = palette_couleurs_unique) +  
  labs(fill = "Genre", x = "Genre", y = "Total Streams par musique") +
  ggtitle("Whisker Plot : r√©partition du Nombre total de Streams (par musique) par Genre") +
  coord_flip() +
  scale_y_continuous(labels = scales::comma)

```
En analysant le m√™me graphique sous forme de Violin Plot, on observe plus ais√©ment que les genres Rap, Rock et R&B ont beaucoup plus de musiques avec un faible nombre de streams, compar√© aux genres EDM, Pop et Latin(o) qui ont une r√©partition plus √©quilibr√©e. 

```{r, echo=FALSE}
# Cr√©er le graphique de type "Whisker Plot" par genre avec la moyenne
ggplot(data, aes(x = fct_reorder(playlist_genre, -total_streams, .desc = TRUE), y = total_streams, fill = playlist_genre)) +
  geom_violin() +
  stat_summary(fun = "mean", geom = "point", shape = 18, size = 3, color = "black", position = position_dodge(width = 0.75)) +  # Ajouter la moyenne
  scale_fill_manual(values = palette_couleurs_unique) +  
  labs(fill = "Genre", x = "Genre", y = "Total Streams par musique") +
  ggtitle("Violin Plot :  r√©partition du Nombre total de Streams (par musique) par Genre") +
  scale_y_continuous(labels = scales::comma)

```


Comme on peut le voir dans le tableau ci dessous, le genre EDM contient beaucoup moins de musique par rapport √† la Pop ou au Latin(o), donc le petit nombre de musiques extr√™mes (en nombre de stream) √† une grande influence sur la moyenne de stream ce qui a tendance √† fausser notre classement initial.

```{r, echo=FALSE}

tableau_genre_musiques <- data %>%
  count(playlist_genre) %>%
  rename(Genre = playlist_genre, Nombre_de_musiques = n)

tableau_genre_musiques
```

Que faut-il conclure pour cette question ? Le classement par la m√©diane est plus pertinent, ce qui place donc la **Pop comme le genre le plus populaire**.
Pour le genre Latin(o), les musiques font g√©n√©ralement moins de streams que l'EDM et la Pop sauf quelques cas particuliers qui apparaissent dans notre top 15 des musiques les plus populaire.

‚ö†Ô∏è Il est √† noter cette √©tude est bas√©e sur les musiques pr√©sente dans le dataset et pas sur toute les musiques existantes.

```{r}
ggplot(data, aes(area = total_streams, fill = playlist_genre, subgroup = playlist_genre, label = paste(Track))) +
  geom_treemap() +
  geom_treemap_subgroup_border(colour = "black", size = 2) +
  geom_treemap_subgroup_text(place = "left", grow = TRUE, alpha = 0.5, colour = "black", fontface = "italic", min.size = 0) + geom_treemap_text(colour = "white", place = "topleft", grow = TRUE, reflow = TRUE) + 
  labs(title = "R√©partition des musiques les plus stream√©es par genre") +
  theme(legend.position = "none")
```


> Est ce que l'energie d'une musique joue un r√¥le important dans sa popularit√© ?

C'est une question l√©gitime, existe t'il une corr√©lation entre l'energie d'une musique ainsi que sa popularit√© (total du nombre de streams sur les 2 plateformes). 
Nous analysons cette question avec 2 graphiques utilisant les m√™mes donn√©es. Le 1er graphique est un scatter plot avec une moyenne mobile du nombre de streams. Le 2nd est le m√™me graphique sans le nuage de points pour mieux analyser la moyenne mobile qui semble constante sur le 1er.
 
```{r}
ggplot(data, aes(x = energy, y = total_streams)) + geom_point() +
  geom_smooth() +
  labs(x = "Energie", y = "Total Streams", title = "Correlation entre Energie et Total Streams") +
  theme_minimal()
```

On peut remarquer que la densit√© d'√©nergie avec le plus de musiques se situe entre 0.4 et 1.

```{r}
ggplot(data, aes(x = energy, y = total_streams)) +
  geom_smooth() +
  labs(x = "Energie", y = "Total Streams", title = "Correlation entre Energie et Total Streams") +
  theme_minimal()
```

L'√©volution de la moyenne mobile est nettement plus analysable sans le nuage de points. On peut remarquer que la moyenne du nombre de streams augmente entre 0 et 0.75 d'energy pour ensuite diminuer entre 0.75 et 1. Il y a une croissance de pr√®s de 25% entre 0.25 et 0.75 d'energy et une chute de 33% du nombre de streams entre 0.75 et 1. On peut donc conclure qu'il y a une certaine corr√©lation entre l'energy et le nombre de streams.

> Quelles ann√©es ont connu le plus de streams ?

> Quelle est l'√©volution de la r√©partition des genres de musique au fil des ann√©es ?

Dans le graphique ci-dessous, on voit les streams totaux des musiques sorties sur la m√™me ann√©e, selon leur genre. On s'int√©resse seulement √† la p√©riode 2000 2019 (le dataset ne comprenant qu'un faible √©chantillon de musiques en 2020).



```{r echo=FALSE}
# Turn release date to years
data$track_album_release_date <- as.Date(data$track_album_release_date)
data$track_album_release_year <- as.numeric(format(data$track_album_release_date, "%Y"))

data_2000_2019 <- data %>%
  filter(track_album_release_year >= 2000 & track_album_release_year <= 2019) %>%
  group_by(track_album_release_year, playlist_genre) %>%
  summarise(total_streams = sum(total_streams))

#Fill les genre manquant par ann√©es
years <- seq(2000, 2019)
genres <- unique(data_2000_2019$playlist_genre)
all_combinations <- expand.grid(track_album_release_year = years, playlist_genre = genres)

data_2000_2019 <- all_combinations %>%
  left_join(data_2000_2019, by = c("track_album_release_year", "playlist_genre"))

data_2000_2019$total_streams[is.na(data_2000_2019$total_streams)] <- 0



g1 <- ggplot(data_2000_2019, aes(x = track_album_release_year, y = total_streams, fill = playlist_genre)) +
  geom_area(alpha=0.8 , size=0.5, colour="black") +
  ggtitle("Streams totaux des musiques sorties sur la m√™me ann√©e, selon leur genre") +
  ylab("Nombre Total de streams (S and YT)") +
  xlab("Ann√©es") +
  scale_fill_manual(values = palette_couleurs_unique) +
  scale_y_continuous(labels = scales::comma)

data_2000_2019_perc <- data_2000_2019 %>%
  group_by(track_album_release_year, playlist_genre) %>%
  summarise(total_streams = sum(total_streams)) %>%
  mutate(percentage = total_streams / sum(total_streams))

g2 <- ggplot(data_2000_2019_perc, aes(x = track_album_release_year, y = percentage, fill = playlist_genre)) +
  geom_area(alpha=0.8 , size=0.5, colour="black") +
  ggtitle("Percentage of Total Streams by Genre, by Release Year") +
  ylab("Percentage of Total Streams") +
  xlab("Years") +
  scale_fill_manual(values = palette_couleurs_unique) +
  scale_y_continuous(labels = scales::percent)

plot_grid(g1, g2, ncol = 1)

```

Globalement, on peut voir que les ann√©es 2010 ont connu une explosion des plateformes de streaming de musique commme Spotify ou Youtube, ce qui se traduit par un pic de streams sur la graphique.

Par rapport aux genres, on voit que les musiques Rock ont connu un pic de streams dans les ann√©es 2000, avant de chuter drastiquement. Au contraire, dans la fin des ann√©es 2010, le genre Rap prend de plus en plus d'importance dans le monde de la musique. Le genre Latino a connu une tr√®s grosse √©volution en 2017 et 2018, avec la sortie, entre autres, de **Despacito** de Luis Fonsi et Daddy Yankee ou **MIA** de Bad Bunny et Drake.

> Est-ce que les musiques qui ont le plus de "Views" sur Youtube sont √©galement celle qui ont le plus de "Stream" sur Spotify ? Dans la m√™me id√©e, est-ce que les musiques qui ont le plus de "Views" sont √©galement celle qui ont le plus de "Likes" et de "Comments" ?

Pour cette question, le graphique dynamique est disponible dans l'application **Shiny** d√©di√©e, dans l'onglet **Top 40 Musiques**. Vous pouvez s√©lectionner la variable afin d'afficher le graphique. Nous ferons cette analyse pour un top 15 des musiques, mais dans l'application vous pouvez √©galement aller jusqu'au top 40 gr√¢ce au curseur.


![ScreenShot Shiny Views et Streams](image/shiny_view_stream.png)



Pour commencer, ce que nous pouvons remarquer de ces deux graphiques c'est que le top 15 de Youtube et le top 15 de Spotify n'est pas le m√™me. Il est m√™me tr√®s  √©loign√©, car la seule musique en commun est *Shape of You*. *Despacito*, qui a le plus de "Views" sur Youtube n'est m√™me pas dans le top 40 Stream car il fait environ la moiti√© de "Streams" Spotify par rapport a *Shape of You*.

Deux choses peuvent expliquer ce gros √©cart, soit les donn√©es n'ont pas √©t√© r√©cup√©r√©es au m√™me moment par les API quand le dataset a √©t√© cr√©e (en sachant que ces donn√©es viennent du m√™me dataset) et donc certaines musiques ont fait plus de vue entre temps ou alors elles √©taient pas en "top popularit√©" √† ce moment l√† et donc n'ont pas √©t√© s√©l√©ctionn√©e par l'API. Soit, Youtube est une platforme gratuite et tout le monde ne paye pas un abonnement pour une platforme de musique, donc si une musique commence √† devenir populaire il y a de grande chance qu'on l'√©coute sur cette platforme √† un moment donn√©. De plus tout le monde n'√©coute pas sa musique sur Spotify car il existe d'autres applications payantes (exemple : Deezer), donc il peut √©galement exister des types de profils par rapport aux platforme. 

Dans tout les cas, les **algorithmes** pour les propositions de musiques ne sont **pas identiques** entre Spotify et Youtube, donc les musiques propos√©e ne sont pas identique et cela peut faire **changer** la popularit√© (et donc le nombre de views/streams) d'une musique d'une platforme √† une autre.


![ScreenShot Shiny Likes et Comments](image/shiny_like_comment.png)


On remarque en revanche sur ces deux graphiques plusieurs musiques du top 15 en "Views" √©galement pr√©sentes dans le top 15 "Likes" et "Comments", notamement *Despacito*, *Shape of you* ou *See you again*. Les classements ne sont pas excatement identique, mais on retrouve plusieurs musiques en commun donc il existe surement un **lien** entre le nombre de "views" et le nombre de "likes" / "comments". Nous allons le v√©rifier avec une matrice de corr√©lation.

```{r}
# S√©lectionner uniquement les colonnes n√©cessaires
data_selected <- data %>%
  select(Views, Likes, Comments)

# Cr√©er le graphique de croisements deux √† deux et la matrice de corr√©lation
ggpairs(data_selected, 
        upper = list(continuous = wrap("cor", size = 6, face = "bold", color = "#f00000")),
        lower = list(continuous = wrap("smooth", alpha = 0.7, color = "#2ca02c")),
        diag = list(continuous = wrap("barDiag", fill = "#1f77b4"))) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 12, face = "bold"),
    panel.grid.major = element_line(color = "gray80"),
    panel.grid.minor = element_blank(),
    axis.text = element_text(size = 7),
    axis.title = element_text(size = 10),
    strip.background = element_rect(fill = "gray90"),
    strip.text = element_text(size = 10, face = "bold")
  ) +
  labs(title = "Croisement deux √† deux et matrice de corr√©lation pour Views, Likes et Comments")
```

Dans ce graphique de croisements deux √† deux avec la matrice de corr√©lation, on confirme gr√¢ce aux co√©ffients, que nous avons une **correlation forte** entre les trois variables : Views, Likes et Comments. 

> Est-ce qu'il existe des liens de corr√©lation entre certaines variables : danceability, energy, loudness, speechiness, acousticness, instrumentalness, liveness, valence, tempo, total_streams ?
Et, existe-t-il des liens entre certaines variables et le nombre de streams total ?

De m√™me pour cette question, le graphique dynamique est disponible dans l'application **Shiny** d√©di√©e, dans l'onglet **Matrice de corr√©lation**. Cette matrice est clicable, c'est √† dire que que si vous cliquez sur la case rouge entre energy et loudness, vous aurez le graphique correspondant √† droite et le coeficient de corr√©lation en dessous.

![ScreenShot correlation energy loudness](image/correlation1.png)
La matrice de correlation nous indique qu'il y a une **correlation forte** (0,67) entre l'energie et le volume sonore (loudness), et entre l'energie et l'accoustique (0,53). Mais  √©galement une **corr√©lation moyenne** entre l'accoustique et le volume sonore (0,38). Les autres corr√©lation sont plus faibles, et contrairement √† nos suppositions, il n'y a pas de correlation notable entre le nombre total de streams (Youtube + Spotify) et certaines variables.
