## Introduction ‚ú®
L'√©quipe de projet `The World (Taylor's Version)` est compos√©e de quatres personnes : Marielle CHARON, Kevin HERNANDEZ, Anouchka NEVEU et Amadou ISSAKA AMADOU. Le but de ce projet est de r√©pondre √† plusieurs questions sur le th√®me de la musique et plus pr√©cisement sur les platformes Spotify et Youtube grace √† la visualisation de donn√©es. Le projet sera d√©velopp√© sous R.

## Donn√©es üí°
Le dataset utilis√© (`Datasetfinal.csv`) est un merge de deux datasets : [Spotify and Youtube](https://www.kaggle.com/datasets/salvatorerastelli/spotify-and-youtube) et [Spotify songs](https://www.kaggle.com/datasets/sujaykapadnis/spotify-songs). Le merge final p√®se 6.55 MB et est sous format CSV. Il contient 3668 √©l√©ments. La cl√© qui a servi au merge est l'ID de la musique sur Spotify.

Les deux jeux de donn√©es contiennent des donn√©es datant de **2023** collect√©es depuis les API officielles de YouTube et Spotify. On a, notamment, les 10 musiques les plus populaires d'une vari√©t√© d'artistes.

> Il poss√®de √† l'heure actuelle 50 features, avant cleaning de celles pertinentes.
<br>
On regroupe les features sous ces cat√©gories :
<br><br>

| Cat√©gorie | Features associ√©es |
| --- | --- |
| Informations g√©n√©rales | artist, track_name, album, album_type, duration_ms, channel, description, track_album_release_date, ... |
| Scores musicaux | danceability, energy, key, loudness, acousticness, instrumentalness, liveness, valence, tempo |
| Popularit√© | views, likes, comments, stream, track_popularity |
| Variables suppl√©mentaires | uri (Spotify ID), url_spotify, url_youtube, licensed, ... |

> Les variables suppl√©mentaires n'expliquent pas la donn√©e pour l'analyse, mais sont utilis√©es pour structurer le dataset.
<br>
Les features se r√©partissent selon plusieurs types : nominales (nom de l'artiste/musique/album, ...), discr√®tes (tonalit√©) ou continues (scores musicaux).


```{r, echo=FALSE, include=FALSE}
# DATASET CLEANING AND PRACTICAL CODE

# Install packages if necessary
# install.packages("cowplot")

# library import
library(ggplot2)
library(readr)
library(dplyr)
library(forcats)
library(devtools)
library(palettetown)
library(cowplot)
library(stats)

# import dataset
data <- read_csv("data/datasetfinal.csv")
data <- data.frame(data)

# clean dataset
data <- data %>%
  select(-c(playlist_name, playlist_id, Url_spotify, Url_youtube, Title, Duration_ms, Danceability, Energy, Key, Loudness, Speechiness, Acousticness, Instrumentalness, Liveness, Valence, Tempo, track_name, track_artist)) %>%   # remove useless features
  na.omit() %>%   # remove incomplete rows
  distinct(Uri, .keep_all = TRUE)   # remove duplicated rows
  

# add relevant features to dataset
data$total_streams <- data$Stream + data$Views
data <- arrange(data, desc(total_streams))
#D√©finition des couleurs pour les genres de musique (graphiques coh√©rents)

palette_couleurs_unique <- c("rap" = "#4A79E7",
                             "pop" = "#F28E2B",
                             "r&b" = "#E15759",
                             "edm" = "#76B7E2",
                             "latin" = "#59A13F",
                             "rock" = "#9999EF")
```


***

## R√©ponses aux questions ü§î 

> Quelles sont les chansons les plus populaires sur YouTube et Spotify ?

> Y a-t'il une corr√©lation entre les genres de musique et leur cl√© musicale ?

Dans le graphique ci-dessous, on voit les 15 chansons les plus √©cout√©es (streams cumul√©s sur YouTube et Spotify). On voit rapidement que *Ed Sheeran* domine le classement puisqu'il cumule 3 des 15 chansons les plus √©cout√©es.
‚ö†Ô∏è **CELA NE REPRESENTE PAS LES ARTISTES AVEC LE PLUS DE STREAMS TOTAUX CUMULES**

On d√©cide d'analyser ces musiques en fonction de leur cl√© musicale. Dans le dataset, chaque cl√© est associ√©e √† un entier selon [cet encodage](https://en.wikipedia.org/wiki/Pitch_class#:~:text=%5Bedit%5D-,Pitch%20class,-Pitch%0Aclass).
Globalement, plus une cl√© est √©lev√©e, plus une chanson a tendance √† √™tre a√Øgue. A l'inverse, une chanson √† cl√© basse sera plus grave.

Sur l'ensemble du dataset, la cl√© moyenne est :

```{r, echo=FALSE}
mean(data$key)
```
soit un *Fa*.


```{r, echo=FALSE}
# PLOT 1 : Top X songs from total streams (S and YT) by artist and key

# stacked bar plot
ggplot(head(data, 15), aes(fill = key, y = total_streams, x = fct_reorder(Artist, total_streams, sum))) + 
    geom_bar(position = "stack", stat = "identity") +
    geom_text(aes(label = Track), position = position_stack(vjust = 0.5), color = "white", size = 2) +
    ggtitle("Top 15 des musiques avec le Nombre total de streams (S and YT) par artistes et cl√© ") +
    ylab("Nombre Total de streams (S and YT)") +
    xlab("Artistes") +
    
    # turning the graph sideways and switching from scientific notation to regular notation for numbers
    coord_flip() +
    scale_y_continuous(labels = scales::comma)
```

Si on s'int√©resse uniquement aux 15 premi√®res chansons, la cl√© moyenne devient alors :

```{r, echo=FALSE}
mean(head(data,15)$key)
```
plus proche d'un *Mi* (soit une cl√© inf√©rieure).

```{r, echo=FALSE}
ggplot(data, aes(x = fct_reorder(playlist_genre, -key, mean), y = key, fill = playlist_genre)) +
  geom_boxplot() +
  scale_fill_manual(values = palette_couleurs_unique) +  
  labs(fill = "Genre", x = "Genre", y = "Cl√©") +
  ggtitle("Whisker Plot des cl√©s par Genre pour toutes les musiques") +
  coord_flip()

```



En regardant les genres de toutes les musiques du dataset, on voit que le genre avec la cl√© m√©diane la plus √©lev√©e est le rap. Les genres les moins vari√©s en terme de de cl√©s musicales sont le rock et l'EDM (Electronic Dance Music).

‚ö†Ô∏è Il est √† noter que la classification du genre des musiques dans le dataset peut parfois √™tre hasardeuse.





> Quelle est la dur√©e moyenne des chansons par artiste ? Est-ce qu'il y a des artistes qui ont des chansons plus longues ou plus courtes que la moyenne ?

L'id√©e √† travers ces diff√©rentes interrogations est de pouvoir situer les artistes en fonction de la dur√©e moyenne de leurs chansons. Pour cela, nous allons dans un premier temps voir la ***distribution*** de la dur√©e moyenne de chansons √† l'aide d'un ***histogramme***, et ensuite faire la ***comparaison*** entre ces artistes. Avant cela, il est important de noter que :


```{r duration_stats, echo=FALSE,}
Convert_en_m <- function(ms){
  minute <- ms/60000
  intPart <- floor(minute)
  decimalPat <- minute - intPart
  decimalPat <- floor(decimalPat * 60)
  return(paste(c(intPart,"mn",decimalPat,"s"),collapse = ''))
}

mean_in_s <- round(mean(data$duration_ms)/1000,2)
max_in_s <- round(max(data$duration_ms)/1000,2)
min_in_s <- round(min(data$duration_ms)/1000,2)
  
paste(c("la dur√©e moyenne d'un song est de: ", mean_in_s, "s soit ",Convert_en_m(mean(data$duration_ms))),collapse = '')
paste(c("Le song le plus long dure: ", max_in_s, "s soit ",Convert_en_m(max(data$duration_ms))),collapse = '')
paste(c("Le plus court dure: ", min_in_s , "s soit ",Convert_en_m(min(data$duration_ms))),collapse = '')

```

```{r Histogramme, echo=FALSE, fig.align='center'}

dfArtisDuration_mean <- data %>% group_by(Artist) %>% summarise (duration_mean = mean(duration_ms)) %>% mutate(duration_mean_in_sec = duration_mean/1000)

dfArtisDuration_sup_mean <- dfArtisDuration_mean %>% filter(duration_mean_in_sec > mean_in_s) %>% arrange(desc(duration_mean))

dfArtisDuration_infEg_mean <- dfArtisDuration_mean %>% filter(duration_mean_in_sec <= mean_in_s) %>% arrange(duration_mean)


ggplot(dfArtisDuration_mean, mapping = aes(x = duration_mean_in_sec))+
   geom_histogram(mapping = aes(fill = ifelse(duration_mean_in_sec <= mean(duration_mean_in_sec),"Below average","Above average")), binwidth = 20) +
   scale_fill_discrete(name ='Classification by average song duration')+
   ggtitle("Distribution of song duration") +
   xlab("Duration in secondes") +
   ylab("Number of artists")

```

On constate √† travers cet histogramme que toutes les chansons de notre dataset durent plus de 100s soit plus d'une 1mn40s et qu'il y en a qui vont jusqu'√† plus de 400s soit plus de 6mn. Cependant malgr√© la faible domination des songs dans la moyenne g√©n√©rale de dur√©e, un certain nombre d'artistes proposent une discographie de musiques plus longues.

Si l'on pousse la curiosit√© encore plus loin, on peut faire le top 10 des artistes qui produisent en moyenne plus de longues ou au contraire plus de courtes musiques. Pour cela, nous, utiliserons un ***Bar_Chart*** pour faire la ***comparaison*** entre ces artistes.

```{r Artist mean duration , echo=FALSE, fig.align='center', fig.height=6, fig.width=15}

g1 <- ggplot(head(dfArtisDuration_sup_mean,10),mapping = aes(y = duration_mean_in_sec, x=Artist, fill = Artist )) +
  geom_bar(position = "stack", stat = "identity") +
  geom_hline(yintercept = mean_in_s) +
  annotate("text", x=-1, y = mean_in_s + 10, label='Mean', hjust = 'left' )+
  geom_text(aes(label = round(duration_mean_in_sec,2), angle = 70), position = position_stack(vjust = 1.1)) +
  theme(axis.text.x = element_blank(), axis.title.x = element_blank()) +
  ggtitle("Top 10 artists with the longest songs (average)") +
  ylab("Duration in secondes") 
  
 
g2 <- ggplot(head(dfArtisDuration_infEg_mean,10), mapping = aes(y = duration_mean_in_sec,x=Artist,fill = Artist)) +
   geom_bar(position = "stack", stat = "identity") +
   geom_hline(yintercept = mean_in_s) +
   annotate("text", x=-1, y = mean_in_s + 10, label='Mean', hjust = 'left' )+
   geom_text(aes(label = round(duration_mean_in_sec,2), angle = 70), position = position_stack(vjust = 1.1)) +
   theme(axis.text.x = element_blank(), axis.title.x = element_blank()) +
   ggtitle("Top 10 artists with the shortest songs (average)") +
   ylab("Duration in secondes") 


plot_grid(g1,g2)

```


```{r Artist mean duration 2, echo=FALSE, fig.align='center', fig.height=6, fig.width=15}

# g1 <- ggplot(head(dfArtisDuration_sup_mean,10),mapping = aes(y = duration_mean_in_sec, x=Artist, fill = duration_mean_in_sec )) +
#   scale_fill_continuous(name="Duration in seconde class")+
#   geom_bar(position = "stack", stat = "identity") +
#   geom_hline(yintercept = mean_in_s) +
#   annotate("text", x=-1, y = mean_in_s + 10, label='Mean', hjust = 'left' )+
#   ggtitle("Top 10 artists with the longest songs (average)") +
#   ylab("Duration in secondes") +
#   xlab("Artists") +
#   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
#   
#  
# g2 <- ggplot(head(dfArtisDuration_infEg_mean,10), mapping = aes(y = duration_mean_in_sec,x=Artist,fill = duration_mean_in_sec)) +
#    scale_fill_continuous(name="Duration in seconde class")+
#    geom_bar(position = "stack", stat = "identity") +
#    geom_hline(yintercept = mean_in_s) +
#    annotate("text", x=-1, y = mean_in_s + 10, label='Mean', hjust = 'left' )+
#    ggtitle("Top 10 artists with the shortest songs (average)") +
#    ylab("Duration in secondes") +
#    xlab("Artists")+ 
#    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
# 
# 
# plot_grid(g1,g2)

```


Sur ces 2 graphiques, on peut voir que dans les deux tops 10, la moyenne des artistes se d√©tache largement de la dur√©e moyenne du dataset et que "*Bob Marley & The Wailers*" fait plus de longues chansons contrairement √† "*Pouya*" qui a la moyenne la plus basse.

‚ö†Ô∏è Il est important de relativis√©, car il ne faut pas perdre de vue que nous sommes en pr√©sence d'un dataset qui ne contient pas toute la discographie de ces artistes.

Avec ces constats, on est en droit de se demander si la dur√©e des songs, n'a pas d'impact sur la popularit√© de la musique.

> Les chansons plus longues ont-elles une popularit√© diff√©rente ?

En tant que m√©lomane, on a tendance √† croire que les chansons les plus longues sont moins populaires en raison de la tendance actuelle des artistes pour les musiques de courte dur√©e. Afin d'affirmer ou d'infirmer cette th√©orie, nous allons √† l'aide d'un ***Scatter Plot***, √©tudier la ***relation*** entre la dur√©e et la popularit√© des diff√©rents songs du dataset.

```{r duration & popularity, echo=FALSE, fig.align='center'}
data %>% select(track_popularity, duration_ms) %>% 
  ggplot( mapping = aes(y = track_popularity, x=duration_ms/1000 )) + 
  geom_point() + 
  geom_smooth()+
  ggtitle("Duration & Popularity Scattter Plot") +
  xlab("Duration in secondes") +
  ylab("Track popularity in %")

```

√Ä travers ce nuage de points, on observe :

-   une forte concentration de songs ayant une dur√©e comprise entre 200 et 300 secondes et avec une popularit√© oscillant entre 60 et 80 %.
-   les songs les plus, mais aussi les moins populaires se situent dans la m√™me plage de dur√©e,
-   les musiques les plus courtes et les plus longues partagent la m√™me plage de popularit√©.
-   la dispersion du nuage de points par rapport √† la droite de r√©gression.

Tout ceci nous pousse √† douter de l'existence d'une r√©elle relation entre la popularit√© et la dur√©e d'une musique. Dans le doute, on se r√©f√®re au coefficient de corr√©lation qui est de :

```{r Coefficient, echo=FALSE,}
coeff<-cor(x = data$duration_ms, y =data$track_popularity)
coeff
```

Le r√©sultat n√©gatif traduit une corr√©lation n√©gative, c'est-√†-dire que les deux variables √©voluent en direction oppos√©e, ce qui conforte nos soup√ßons sur l'impopularit√© des longues chansons. Cette relation demeure tr√®s faible et nous pensons que la taille de notre jeu de donn√©es ne nous permet pas de s'assurer ais√©ment de cette relation.





> Quel genre de musique est le plus populaire sur Spotify/Youtube ?

Dans le graphique ci-dessous, nous pouvons voir le classement des genres de musiques par rapport au nombre moyen de stream (sur spotify et youtube) que fait une musique de ce genre, ce qui donne donc un classement de popularit√©. On choisi cette m√©thode de *"nombre moyen de stream que fait une musique"* pour cat√©goriser la popularit√© des genres car nous ne pouvons pas simplement afficher un nombre total de Stream pour chaque genre sachant qu'il n'y a pas un nombre √©gal de musique par genre. Il faut diviser le nombre total de stream par genre par le nombre de musique de ce genre, ce qui donne un nombre moyen de stream pour chaque genre.


```{r, echo=FALSE}

# Calculer la moyenne du nombre de streams (par musique) pour chaque genre de musique
total_streams_genre <- data %>%
  group_by(playlist_genre) %>%
  summarise(total_streams = sum(total_streams),
            total_tracks = n()) %>%
  mutate(mean_streams_per_track = ceiling(total_streams / total_tracks))  # Arrondir √† l'entier sup√©rieur

# Cr√©er le graphique en utilisant la moyenne du nombre de streams pour chaque genre
ggplot(total_streams_genre, aes(x = reorder(playlist_genre, mean_streams_per_track, .desc=TRUE), y = mean_streams_per_track, fill = playlist_genre)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = mean_streams_per_track), position = position_stack(vjust = 0.5), color = "black", size = 3) +  # Ajouter le nombre de streams moyen par genre
  scale_fill_manual(values = palette_couleurs_unique) +  
  labs(x = "Genre de musique", y = "Nombre de stream moyen", fill = "Genre") +
  ggtitle("Nombre de streams moyen (d'une musique) pour chaque genre de musique") +
  coord_flip() +
  scale_y_continuous(labels = scales::comma)

```

La premiere chose que l'on remarque c'est que l'**EDM** (Electronic Dance Music) est en t√™te de classement suivie par la **Pop** et les musiques **Latin(o)**. Pourtant si on reprend les 15 musiques les plus populaire et qu'on les classe par genre, on se rend compte que le **Latin(o)** domine le classement, suivit par la **Pop** puis enfin l'**EDM**. Comme le montre le graphique ci-dessous.


```{r, echo=FALSE}
# Cr√©er le graphique √† barres empil√©es par genre
ggplot(head(data, 15), aes(fill = Track, y = total_streams, x = fct_reorder(playlist_genre, total_streams, .desc=TRUE))) +
  geom_bar(position = "stack", stat = "identity") +
  ggtitle("Top 15 des musiques (par nombre total de streams) par genre") +
  labs(y = "Total streams (S and YT)", x = "Genre", fill = "Top 15 Musiques") +
  scale_y_continuous(labels = scales::comma)

```

Pour r√©sumer ces deux graphiques, dans ce dataset, le genre de musique le plus populaire est l'EMD (sur un nombre moyen d'√©coute) mais parmi le top 15 des musiques, le genre de musique le plus populaire est le Latin(o).
Alors, comment expliquer cette diff√©rence de r√©sulat ? 

Grace au diagramme Whisker Plot [(d√©finition)](https://cdn2.boryl.fr/2020/11/3d5689a5-box-plot-boi%CC%82tes-a%CC%80-moustaches--300x223.png) ci-dessous, on voit que le classement par la m√©diane nous donne encore une information diff√©rente en mettant la Pop en premi√®re place. C'est normal et m√™me plus juste car la **moyenne est sensible aux "outliers"**, tandis que la m√©diane est plus robuste √† leur pr√©sence. Si un petit nombre de valeurs extr√™mes sont significativement plus √©lev√©es que les autres valeurs de l'ensemble de donn√©es, elles peuvent tirer la moyenne vers le haut, tandis que la m√©diane reste relativement stable. De plus l'impact sur la moyenne peut varier en fonction de la quantit√© de donn√©es et de la r√©partition des valeurs extr√™mes.

```{r, echo=FALSE}
# Cr√©er le graphique de type "Whisker Plot" par genre avec la moyenne
ggplot(data, aes(x = fct_reorder(playlist_genre, -total_streams, .desc = TRUE), y = total_streams, fill = playlist_genre)) +
  geom_boxplot() +
  stat_summary(fun = "mean", geom = "point", shape = 18, size = 3, color = "black", position = position_dodge(width = 0.75)) +  # Ajouter la moyenne
  scale_fill_manual(values = palette_couleurs_unique) +  
  labs(fill = "Genre", x = "Genre", y = "Total Streams par musique") +
  ggtitle("Whisker Plot r√©partition du Nombre total de Streams (par musique) par Genre") +
  coord_flip() +
  scale_y_continuous(labels = scales::comma)

```

Comme on peut le voir dans le tableau ci dessous, le genre EDM contient beaucoup moins de musique par rapport √† la Pop ou au Latin(o), donc le petit nombre de musiques extr√™mes (en nombre de stream) √† une grande influence sur la moyenne de stream ce qui a tendance √† fausser notre classement initial.

```{r, echo=FALSE}

tableau_genre_musiques <- data %>%
  count(playlist_genre) %>%
  rename(Genre = playlist_genre, Nombre_de_musiques = n)

tableau_genre_musiques
```

Que faut-il conclure pour cette question ? Le classement par la m√©diane est plus pertinent, ce qui place donc la **Pop comme le genre le plus populaire**.
Pour le genre Latin(o), les musiques font g√©n√©ralement moins de streams que l'EDM et la Pop sauf quelques cas particuliers qui apparaissent dans notre top 15 des musiques les plus populaire.

‚ö†Ô∏è Il est √† noter cette √©tude est bas√©e sur les musiques pr√©sente dans le dataset et pas sur toute les musiques existantes.



> Est ce que l'energy d'une musique joue un r√¥le important dans sa popularit√© ?

C'est une question l√©gitime, existe t'il une corr√©lation entre l'energie d'une musique ainsi que sa popularit√© (total du nombre de streams sur les 2 plateformes). 
Nous analysons cette question avec 2 graphiques utilisant les m√™mes donn√©es. Le 1er graphique est un scatter plot avec une moyenne mobile du nombre de streams. Le 2nd est le m√™me graphique sans le nuage de points pour mieux analyser la moyenne mobile qui semble constante sur le 1er.

```{r}
ggplot(data, aes(x = energy, y = total_streams)) + geom_point() +
  geom_smooth() +
  labs(x = "Energy", y = "Total Streams", title = "Correlation between Energy and Total Streams") +
  theme_minimal()
```

On peut remarquer que la densit√© d'√©nergie avec le plus de musiques se situe entre 0.4 et 1.

```{r}
ggplot(data, aes(x = energy, y = total_streams)) +
  geom_smooth() +
  labs(x = "Energy", y = "Total Streams", title = "Correlation between Energy and Total Streams") +
  theme_minimal()
```

L'√©volution de la moyenne mobile est nettement plus analysable sans le nuage de points. On peut remarquer que la moyenne du nombre de streams augmente entre 0 et 0.75 d'energy pour ensuite diminuer entre 0.75 et 1. Il y a une croissance de pr√®s de 25% entre 0.25 et 0.75 d'energy et une chute de 33% du nombre de streams entre 0.75 et 1. On peut donc conclure qu'il y a une certaine corr√©lation entre l'energy et le nombre de streams.
